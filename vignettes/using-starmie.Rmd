---
title: "starmie: Basic Usage"
author: "Stuart Lee, Gerry Tonkin-Hill"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 4
    keep_md: true
vignette: >
  %\VignetteIndexEntry{starmie Basic Usage}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# Starmie: making population structure analyses easier 

A very common part of modern population genetics analysis is inferring
underlying population structure from genetic markers such as single
nucleotide polymorphisms (SNPs) or microsatellites. The two main methods
for this task are the Bayesian STRUCTURE algorithm or the frequentist
ADMIXTURE. We have found that processing the output of these programs and
performing meaningful inference and visualisation of the results is far more
difficult than it should be. This is why we wrote starmie. 

Some key features:

  * Parse output from STRUCTURE or ADMXITURE into a useable data structure in R.
  * Plot model diagnostics to perform inference on choice of 'K'.
  * Create the 'standard' STRUCTURE bar plot showing cluster memberships.
  * Plot model checks such as MCMC chains on the admixture coeffecient $\alpha$
    and the log-likelihood.
  * Interactively visualising output from STRUCTURE analysis

This vignette outlines how to use starmie to do basic tasks after running 
STRUCTURE at the command line.

## A basic STRUCTURE pipeline in R.

To use all the options in starmie for STRUCTURE output, we require 
for each run the 'out_f' file produced by the program and the logging information
so we can produce MCMC diagnostics. To get the latter the output of STRUCTURE
must be redirected to a file. Below we present an example of running STRUCTURE
in multiple runs for each K in parallel. We assume that the `mainparams` and
`extraparams`  files are in the same directory and that the user has access
to the STRUCTURE binary. Also make sure RANDOMIZE option is turned off,
so independent seeds can be set in each run.

```{r parallel-structure, eval=FALSE}
# use parallel library
library(parallel)
n.cores <- detectCores() # run on all possible cores machine has
# prelim setup
structure_binary <- "/path/to/structure"
# number of Ks to try
tryK <- 1L:20L
# number of runs for each K
n.runs <- 1L:20L

# output files (will be appended by out_f from structure)
out_files <- outer(n.runs, tryK, 
                   function(x,y) paste0("str_run_", 
                                        stringr::str_pad(x, width = 2, pad = 0), 
                                        "_K_", 
                                        stringr::str_pad(y, width = 2, pad = 0), 
                                        ".out")
                   )

log_files <- gsub("out", "log", out_files)

# create function to run structure, assumes that mainparams/extraparams 
# file is in same path as current wd in Rscript
run_structure <- function(out_file, log_file) {
  k <- as.integer(stringr::str_extract(out_file, "[0-9]{2}\\b"))
  return(system(paste(structure_binary, 
                      "-K", k, 
                      "-D", round(runif(1) * 1e8), 
                      "-o", out_file, "&>", log_file)))
}

# prepare run with mcapply
mcmapply(run_structure, out_files, log_files, 
                    mc.cores = n.cores, mc.set.seed = TRUE)

```


## Parsing STRUCTURE files, the 'struct' object

The basic unit of analysis for `starmie` is the `struct` object, which contains
the model information in the STRUCTURE out_f file and optionally the logging
information for the MCMC diagnostics. As an example, we have run STRUCTURE
on [simulated microsatellite data](http://pritchardlab.stanford.edu/software/example-data/locprior.str) 
from the STRUCTURE example data and save the out_f. To create a `struct` object
from a run we use the following:
```{r struct-example}
library(starmie)
# path to file name
k6_file <- system.file("extdata/microsat_testfiles/", "locprior_K6.out_f", 
                       package = "starmie")
# create struct object
k6_msat <- loadStructure(k6_file)

k6_msat
```

The STRUCTURE object contains the following information about a single run:
```{r struct-object, echo=FALSE}
list_names <- names(k6_msat)
list_description <- c("K parameter supplied to STRUCTURE",
                      "Input parameters",
                      "Assigned cluster membership proportions",
                      "Pairwise Fst values between inferred clusters",
                      "Average nucleotide distance within clusters",
                      "Within cluster average Fst values",
                      "Model fit diagnositcs", 
                      "Individual ancestral probability of membership to cluster",
                      "Estimated ancestral allele frequencies for each cluster",
                      "MCMC burn-in diagnositcs",
                      "MCMC post burn-in diagnostics")

knitr::kable(data.frame(attributes = list_names, 
                        description = list_description))
```

Of most interest to users would be the `ancest_df` which is the Q-matrix of individual
cluster membership probabilities. To extract that information for inspection 
use the helper function `getQ`.

```{r qhat}
Q_hat <- getQ(k6_msat)
```

## Why you're here: the infamous bar plot...

To make the bar-plot simply type:

```{r plot-bar}
plotBar(k6_msat, facet = FALSE)
```

This will group the known sample labels into population labels if they were 
supplied to the STRUCTURE run.
Alternatively, you can facet the inferred cluster labels to make it easier to see 
outliers and geographical groupings.

```{r plot-bar2}
plotBar(k6_msat)
```

If you have not given population labels to your samples you can also add them 
using the `populations` argument.


## Loading multiple 'struct' objects the 'structList'

The `structList` is a container for manipulating multiple `struct` objects.
Some potential use-cases are:

* load multiple $K$ values from different runs and perform model comparisons.
* pool a sequence of runs over the same value of $K$ and perform CLUMPPing

On our example microsatellite data to add the second run for 
the results of running STRUCTURE $K$ = 6 ,we first load the output file, and
then pass both `struct` objects to the `structList` function.
```{r structList}
k6_file_run2 <- system.file("extdata/microsat_testfiles/", 
                            "run2_locprior_K6.out_f", 
                       package = "starmie")

k6_run2 <- loadStructure(k6_file_run2)

k6_all <- structList(k6_msat, k6_run2)

k6_all
```

We can also compare the cluster labelling by using `plotMultiK` (and see
that label-switching over different MCMC runs is a problem!)

```{r plot-multiK}
plotMultiK(k6_all)
```


## Diagnostics: or checking out your chains

A very simple approach to determining whether you need to rerun a STRUCTURE a model
is to plot the estimated logLikelihood over each iteration over the post burn-in MCMC
phase. If the chains have converged the log-likelihood should stabilise towards the final
iterations and the variance within a run should be relatively low. The `plotMCMC`
can plot the log-likelihood or admixture coeffecient against the iteration over different
runs and different $K$ values. Note this requires the logging file to be read by `loadStructure`. 

Here we show an example when $K$ = 10 and the number of runs is also 10.
```{r mcmc1}
library(dplyr)
multiple_runs_k10 <- exampleStructure("mcmc_diagnostics")

# not run print multiple_runs_k10

mcmc_out <-plotMCMC(multiple_runs_k10, facet = FALSE)

mcmc_out$mcmc_info %>% group_by(run) %>% summarise(mean_LL = mean(LogL), var_LL = var(LogL))

```


## Inference on K is hard

Usually you would run STRUCTURE multiple times for multiple values of $K$ and
then use estimates of the log-likelihood to determine the 'best' choice of
$K$ that explains the population structure in your data. There are two choices
for model selection - either use the maximum mean log-posterior probability
estimated by STRUCTURE or use the Evanno method. The `bestK` function returns the
value of $K$ that is estimated by these methods and also produces diagnostic plots.

```{r evanno-lyf}
multi_K <- exampleStructure("multiple_runs")
bestK(multi_K)
bestK(multi_K, "structure")
```

## CLUMPPING together

We have written R implementations of the popular CLUMMP and CLUMPAK algortihms for
combining Q-matrices over different runs of STRUCTURE. Usually, this step is performed
after choosing a value for $K$, when the analyst would like to refine their estimates
of cluster memberships. To perform CLUMPPING create a `structList` consisting of the
same value of $K$ for multiple runs. In each case the Q-matrices and a matrix of column permutations
for each run are returned.

We return the the example of our two runs of $K$ = 6, stored in `k6_all` defined
above. 

```{r clump-example}
Q_list <- lapply(k6_all, getQ)
clumpak_results <- clumpak(Q_list)

clumppy <- clumpp(Q_list, method = "greedy")

# plot the results
plotMultiK(clumppy$Q_list)
```

We can see thta the clumpping has worked compared to the first plot.

# Putting it together - shining starmie
Coming soon...

# Why starmie?
There's a reason. It's not very good though. 

# References


# session info
```{r session-info}
sessionInfo()
```
