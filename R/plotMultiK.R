# plotMultiK.R
# Function for plotting Q matrices for multiple K values from Structure or Admixture runs.

#' Generate a barplot of a Structure or Admixture run.
#' @param  cluster_runs a list multiple cluster runs of type \code{\link{struct}} or \code{\link{admix}} or matrix for Q in the same format as that generated by loadAdmixture.
#' @param  populations a data.frame that contains the sample number as the first column and the population as the second.
#' @param  plot if FALSE returns a data.frame for customised plots
#' @import ggplot2
#' @importFrom data.table melt
#' @export
#' @examples
#' # Read in Structure files
#' structure_files <- system.file("extdata/microsat_testfiles", package="starmie")
#' structure_output_files <- list.files(structure_files, pattern = "*.out_f", full.names = TRUE)
#' cluster_runs <- lapply(structure_output_files[1:6], loadStructure)
#' # Generate barplot
#' plotMultiK(cluster_runs)
#'
plotMultiK <- function(cluster_runs, populations=NULL, plot=TRUE){

  #i/o checks

  if (!all(unlist(lapply(cluster_runs, inherits, "struct")))
      & !all(unlist(lapply(cluster_runs, inherits, "admix")))
      & !all(unlist(lapply(cluster_runs, inherits, "matrix")))) stop("cluster runs must be either all struct or admix objects or a Q matrices")
  if (!is.logical(plot)) stop("plot must be one of TRUE or FALSE")

  #Get Q matrix out of object
  if (class(cluster_runs[[1]])=="struct"){
    Q_list <- lapply(cluster_runs, getQ)
    #If no population labels are given try to use those available in the structure run.
    if (is.null(populations)) {
      if ("Pop" %in% colnames(cluster_runs[[1]]$ancest_df)){
        populations <- cluster_runs[[1]]$ancest_df[,c(1,3)]
      }
    }
  }
  else if(class(cluster_runs[[1]])=="admix"){
    Q_list <- lapply(cluster_runs, function(x) { x$Q_df })
  } else{
    Q_list <- cluster_runs
  }

  plot_results <- plotMultiQ(Q_list, populations)

  if(plot){
    return(plot_results$plot)
  } else{
    return(plot_results$Q_melt)
  }
}

plotMultiQ <- function(Q_list, populations_df){

  #get K labels
  Ks <- unlist(lapply(Q_list, ncol))
  if (length(unique(Ks))!= length(Ks)){
    #Repeated Ks so label with subnumbering
    Ks <- paste(Ks, ave(Ks, Ks, FUN=seq_along), sep=".")
  } else{
    Ks <- as.character(Ks)
  }

  for (i in 1:length(Q_list)){
    Q_list[[i]] <- data.frame(Label=rownames(Q_list[[i]]), Q_list[[i]], K=rep(Ks[[i]], nrow(Q_list[[i]])))
  }

  #Melt and append Q matrices
  Q_melt <- do.call("rbind", lapply(Q_list, melt, id.vars=c("Label","K"), variable.name="Cluster"))

  if (!is.null(populations_df)){
    #Generate a plot with family information
    colnames(populations_df) <- c("Label", "Population")
    Q_melt <- merge(populations_df, Q_melt, by.x="Label", by.y="Label")
  }

  #Generate plot
  Q_melt <- Q_melt[order(Q_melt$Cluster),]
  gg <- ggplot(Q_melt, aes(x=factor(Label), y=value, fill=factor(Cluster)))
  if (!is.null(populations_df)){
    gg <- gg + facet_grid( K ~ Population, scales = "free_x", space = "free_x")
  } else{
    gg <- gg + facet_grid( K ~ ., scales = "free_x", space = "free_x")
  }
  gg <- gg + geom_bar(stat = "identity", width=1)
  gg <- gg + scale_y_continuous(expand=c(0,0), breaks=c(0.25,0.75))
  gg <- gg + coord_cartesian(ylim=c(0,1))
  gg <- gg + xlab("Sample ID") + ylab("Proportion of cluster")
  gg <- gg + theme_bw()
  gg <- gg + guides(fill=guide_legend(title="Cluster"))
  gg <- gg + theme(axis.text.x = element_text(angle = 90))

  #print plot or return
  return(list(Q_melt = Q_melt, plot=gg))
}
